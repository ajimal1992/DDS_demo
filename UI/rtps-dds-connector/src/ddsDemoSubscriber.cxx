// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file ddsDemoSubscriber.cpp
 * This file contains the implementation of the subscriber functions.
 *
 * This file was generated by the tool fastcdrgen.
 */

#define DATASIZE 10

#include <fastrtps/participant/Participant.h>
#include <fastrtps/attributes/ParticipantAttributes.h>
#include <fastrtps/subscriber/Subscriber.h>
#include <fastrtps/attributes/SubscriberAttributes.h>

#include <fastrtps/Domain.h>

#include "ddsDemoSubscriber.h"


ddsDemoSubscriber::ddsDemoSubscriber() : mp_participant(nullptr), CP_reader(nullptr), LPBC_reader(nullptr)
, TL_reader(nullptr), H_reader(nullptr), T_reader(nullptr), L_reader(nullptr), S_reader(nullptr), GL_reader(nullptr), PT_reader(nullptr) {}

ddsDemoSubscriber::~ddsDemoSubscriber() {	Domain::removeParticipant(mp_participant);}

bool ddsDemoSubscriber::init()
{
	// Create RTPSParticipant
	
	ParticipantAttributes PParam;
	PParam.rtps.builtin.domainId = 0; //MUST BE THE SAME AS IN THE PUBLISHER
	PParam.rtps.builtin.leaseDuration = c_TimeInfinite;
	PParam.rtps.setName("Participant_subscriber"); //You can put the name you want
	mp_participant = Domain::createParticipant(PParam);
	if(mp_participant == nullptr)
			return false;
	
	//Register the type
	Domain::registerType(mp_participant,(TopicDataType*) &CP_type);
	Domain::registerType(mp_participant,(TopicDataType*) &LPBC_type);
	Domain::registerType(mp_participant,(TopicDataType*) &TL_type);
	Domain::registerType(mp_participant,(TopicDataType*) &H_type);
	Domain::registerType(mp_participant,(TopicDataType*) &T_type);
	Domain::registerType(mp_participant,(TopicDataType*) &L_type);
	Domain::registerType(mp_participant,(TopicDataType*) &S_type);
	Domain::registerType(mp_participant,(TopicDataType*) &GL_type);		
	Domain::registerType(mp_participant,(TopicDataType*) &PT_type);	
			
			
	// Create Subscriber

	SubscriberAttributes Rparam1;
	Rparam1.topic.topicKind = WITH_KEY;
	Rparam1.topic.topicDataType = CP_type.getName();  //This type MUST be registered
	Rparam1.topic.topicName = CP_type.getName();
	CP_reader = Domain::createSubscriber(mp_participant,Rparam1,(SubscriberListener*)&m_listener);
	if(CP_reader == nullptr)
		return false;
	// std::cout << "Carpark reader initiated" << std::endl;

	SubscriberAttributes Rparam3;
	Rparam3.topic.topicKind = WITH_KEY;
	Rparam3.topic.topicDataType = LPBC_type.getName();  //This type MUST be registered
	Rparam3.topic.topicName = LPBC_type.getName();
	LPBC_reader = Domain::createSubscriber(mp_participant,Rparam3,(SubscriberListener*)&m_listener);
	if(LPBC_reader == nullptr)
		return false;
	// std::cout << "LamppostsBC reader initiated" << std::endl;

	SubscriberAttributes Rparam4;
	Rparam4.topic.topicKind = WITH_KEY;
	Rparam4.topic.topicDataType = TL_type.getName();  //This type MUST be registered
	Rparam4.topic.topicName = TL_type.getName();
	TL_reader = Domain::createSubscriber(mp_participant,Rparam4,(SubscriberListener*)&m_listener);
	if(TL_reader == nullptr)
		return false;
	// std::cout << "Trafficlight reader initiated" << std::endl;

	SubscriberAttributes Rparam5;
	Rparam5.topic.topicKind = WITH_KEY;
	Rparam5.topic.topicDataType = H_type.getName();  //This type MUST be registered
	Rparam5.topic.topicName = H_type.getName();
	H_reader = Domain::createSubscriber(mp_participant,Rparam5,(SubscriberListener*)&m_listener);
	if(H_reader == nullptr)
		return false;
	// std::cout << "Humidity reader initiated" << std::endl;

	SubscriberAttributes Rparam6;
	Rparam6.topic.topicKind = WITH_KEY;
	Rparam6.topic.topicDataType = T_type.getName();  //This type MUST be registered
	Rparam6.topic.topicName = T_type.getName();
	T_reader = Domain::createSubscriber(mp_participant,Rparam6,(SubscriberListener*)&m_listener);
	if(T_reader == nullptr)
		return false;
	// std::cout << "Temperature reader initiated" << std::endl;

	SubscriberAttributes Rparam7;
	Rparam7.topic.topicKind = WITH_KEY;
	Rparam7.topic.topicDataType = L_type.getName();  //This type MUST be registered
	Rparam7.topic.topicName = L_type.getName();
	L_reader = Domain::createSubscriber(mp_participant,Rparam7,(SubscriberListener*)&m_listener);
	if(L_reader == nullptr)
		return false;
	// std::cout << "Light reader initiated" << std::endl;

	SubscriberAttributes Rparam8;
	Rparam8.topic.topicKind = WITH_KEY;
	Rparam8.topic.topicDataType = S_type.getName();  //This type MUST be registered
	Rparam8.topic.topicName = S_type.getName();
	S_reader = Domain::createSubscriber(mp_participant,Rparam8,(SubscriberListener*)&m_listener);
	if(S_reader == nullptr)
		return false;
	// std::cout << "Speeding reader initiated" << std::endl;

	SubscriberAttributes Rparam9;
	Rparam9.topic.topicKind = WITH_KEY;
	Rparam9.topic.topicDataType = GL_type.getName();  //This type MUST be registered
	Rparam9.topic.topicName = GL_type.getName();
	GL_reader = Domain::createSubscriber(mp_participant,Rparam9,(SubscriberListener*)&m_listener);
	if(GL_reader == nullptr)
		return false;
	// std::cout << "GeoLocation reader initiated" << std::endl;
	
	SubscriberAttributes Rparam10;
	Rparam10.topic.topicKind = WITH_KEY;
	Rparam10.topic.topicDataType = PT_type.getName();  //This type MUST be registered
	Rparam10.topic.topicName = PT_type.getName();
	PT_reader = Domain::createSubscriber(mp_participant,Rparam10,(SubscriberListener*)&m_listener);
	if(PT_reader == nullptr)
		return false;
	// std::cout << "Priority reader initiated" << std::endl;
	return true;
}

void ddsDemoSubscriber::SubListener::onSubscriptionMatched(Subscriber* sub,MatchingInfo& info)
{
	if (info.status == MATCHED_MATCHING)
	{
		n_matched++;
		std::cout << "Subscriber matched: " << sub->getAttributes().topic.getTopicName() << std::endl;
	}
	else
	{
		n_matched--;
		std::cout << "Subscriber unmatched" << std::endl;
	}
}

void ddsDemoSubscriber::SubListener::onNewDataMessage(Subscriber* sub)
{
	// std::cout<< "Topic Name: " << sub->getAttributes().topic.getTopicName() <<std::endl;
	std::string topicName = sub->getAttributes().topic.getTopicName();

	if(topicName.compare("Trafficlight") == 0){
		Trafficlight TL;
		
		if(sub->takeNextData(&TL, &m_info)){
			if(m_info.sampleKind == ALIVE){
				// std::cout << "SS command received, count=" << n_msg << std::endl;
				std::cout << "Trafficlight ID=" << TL.ID() << ",value=" << TL.state() << std::endl;
				++n_msg;
			}
		}	
	}	

	else if(topicName.compare("Priority") == 0){
		Priority PT;
		
		if(sub->takeNextData(&PT, &m_info)){
			if(m_info.sampleKind == ALIVE){
				// std::cout << "SS command received, count=" << n_msg << std::endl;
				std::cout << "Priority ID=" << PT.ID() <<  std::endl;
				++n_msg;
			}
		}	
	}	

	else if(topicName.compare("LamppostsBC") == 0){
		LamppostsBC LPBC;
		
		if(sub->takeNextData(&LPBC, &m_info)){
			if(m_info.sampleKind == ALIVE){
				// std::cout << "SS command received, count=" << n_msg << std::endl;
				std::cout << "LamppostsBC ID=" << LPBC.clusterID() << ",value=" << LPBC.value() << std::endl;
				++n_msg;
			}
		}	
	}

	else if(topicName.compare("Humidity") == 0){
		Humidity H;
		
		if(sub->takeNextData(&H, &m_info)){
			if(m_info.sampleKind == ALIVE){
				// std::cout << "SS command received, count=" << n_msg << std::endl;
				std::cout << "Humidity ID=" << H.sensor_id() << ",value=" << H.sensor_val() <<std::endl;
				++n_msg;
			}
		}	
	}	

	else if(topicName.compare("Temperature") == 0){
		Temperature T;
		
		if(sub->takeNextData(&T, &m_info)){
			if(m_info.sampleKind == ALIVE){
				// std::cout << "SS command received, count=" << n_msg << std::endl;
				std::cout << "Temperature ID=" << T.sensor_id() << ",value=" << T.sensor_val() << std::endl;
				++n_msg;
			}
		}	
	}	

	else if(topicName.compare("Light") == 0){
		Light L;
		
		if(sub->takeNextData(&L, &m_info)){
			if(m_info.sampleKind == ALIVE){
				// std::cout << "SS command received, count=" << n_msg << std::endl;
				std::cout << "Light ID=" << L.sensor_id() << ",value=" << L.sensor_val() << std::endl;
				++n_msg;
			}
		}	
	}

	else if(topicName.compare("Speeding") == 0){
		Speeding S;
		
		if(sub->takeNextData(&S, &m_info)){
			if(m_info.sampleKind == ALIVE){
				// std::cout << "SS command received, count=" << n_msg << std::endl;
				std::cout << "Speeding ID=" << S.sensor_id() << ",value=" << S.sensor_val() << std::endl;
				++n_msg;
			}
		}	
	}

	else if(topicName.compare("GeoLocation") == 0){
		GeoLocation GL;
		
		if(sub->takeNextData(&GL, &m_info)){
			if(m_info.sampleKind == ALIVE){
				// std::cout << "SS command received, count=" << n_msg << std::endl;
				std::cout << "GeoLocation ID=" << GL.sensor_id() << ",value=" << GL.sensor_val() << std::endl;
				++n_msg;
			}
		}	
	}

	else if(topicName.compare("Carpark") == 0){
		Carpark CP;
		
		if(sub->takeNextData(&CP, &m_info)){
			if(m_info.sampleKind == ALIVE){
				// std::cout << "SS command received, count=" << n_msg << std::endl;
				std::cout << "Carpark ID=" << CP.sensor_id() << ",value=" << CP.sensor_val() << std::endl;
				++n_msg;
			}
		}	
	}
		
				// Print your structure data here.
				
				/*
				std::cout << "command received, count=" << n_msg << std::endl;
				char ID[DATASIZE];
				char value = st.value();
				std::memcpy(ID,st.ID().data(),DATASIZE); //conversion

				//encode message
				char encoded[20];
				std::strcpy(encoded,ID);
				int len = std::strlen(encoded);
				encoded[len] = ':';
				encoded[len+1] = value;
				encoded[len+2] = '$';
				encoded[len+3] = '\0';
				
				my_serial.write(encoded);
				//std::cout << "DATA=" << cstr << std::endl;
				*/
	std::cout << std::endl;
}

void ddsDemoSubscriber::run()
{
	std::cout << "Waiting for Data, press Enter to stop the Subscriber. "<<std::endl;
	std::cin.ignore();
	std::cout << "Shutting down the Subscriber." << std::endl;
}