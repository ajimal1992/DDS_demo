// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file ddsDemo.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "ddsDemo.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

LamppostsCtrl::LamppostsCtrl()
{

    m_value = false;
}

LamppostsCtrl::~LamppostsCtrl()
{
}

LamppostsCtrl::LamppostsCtrl(const LamppostsCtrl &x)
{
    m_clusterID = x.m_clusterID;
    m_value = x.m_value;
}

LamppostsCtrl::LamppostsCtrl(LamppostsCtrl &&x)
{
    m_clusterID = std::move(x.m_clusterID);
    m_value = x.m_value;
}

LamppostsCtrl& LamppostsCtrl::operator=(const LamppostsCtrl &x)
{
    m_clusterID = x.m_clusterID;
    m_value = x.m_value;
    
    return *this;
}

LamppostsCtrl& LamppostsCtrl::operator=(LamppostsCtrl &&x)
{
    m_clusterID = std::move(x.m_clusterID);
    m_value = x.m_value;
    
    return *this;
}

size_t LamppostsCtrl::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t LamppostsCtrl::getCdrSerializedSize(const LamppostsCtrl& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void LamppostsCtrl::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_clusterID;

    scdr << m_value;

}

void LamppostsCtrl::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_clusterID;
    dcdr >> m_value;
}

size_t LamppostsCtrl::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     


    return current_align;
}

bool LamppostsCtrl::isKeyDefined()
{
    return true;
}

void LamppostsCtrl::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_clusterID;
	  
	 
}
LamppostsBC::LamppostsBC()
{

    m_value = false;
}

LamppostsBC::~LamppostsBC()
{
}

LamppostsBC::LamppostsBC(const LamppostsBC &x)
{
    m_clusterID = x.m_clusterID;
    m_value = x.m_value;
}

LamppostsBC::LamppostsBC(LamppostsBC &&x)
{
    m_clusterID = std::move(x.m_clusterID);
    m_value = x.m_value;
}

LamppostsBC& LamppostsBC::operator=(const LamppostsBC &x)
{
    m_clusterID = x.m_clusterID;
    m_value = x.m_value;
    
    return *this;
}

LamppostsBC& LamppostsBC::operator=(LamppostsBC &&x)
{
    m_clusterID = std::move(x.m_clusterID);
    m_value = x.m_value;
    
    return *this;
}

size_t LamppostsBC::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t LamppostsBC::getCdrSerializedSize(const LamppostsBC& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void LamppostsBC::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_clusterID;

    scdr << m_value;

}

void LamppostsBC::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_clusterID;
    dcdr >> m_value;
}

size_t LamppostsBC::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     


    return current_align;
}

bool LamppostsBC::isKeyDefined()
{
    return true;
}

void LamppostsBC::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_clusterID;
	  
	 
}
Trafficlight::Trafficlight()
{

    m_state = 0;
}

Trafficlight::~Trafficlight()
{
}

Trafficlight::Trafficlight(const Trafficlight &x)
{
    m_ID = x.m_ID;
    m_state = x.m_state;
}

Trafficlight::Trafficlight(Trafficlight &&x)
{
    m_ID = std::move(x.m_ID);
    m_state = x.m_state;
}

Trafficlight& Trafficlight::operator=(const Trafficlight &x)
{
    m_ID = x.m_ID;
    m_state = x.m_state;
    
    return *this;
}

Trafficlight& Trafficlight::operator=(Trafficlight &&x)
{
    m_ID = std::move(x.m_ID);
    m_state = x.m_state;
    
    return *this;
}

size_t Trafficlight::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t Trafficlight::getCdrSerializedSize(const Trafficlight& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void Trafficlight::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_ID;

    scdr << m_state;

}

void Trafficlight::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_ID;
    dcdr >> m_state;
}

size_t Trafficlight::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     


    return current_align;
}

bool Trafficlight::isKeyDefined()
{
    return true;
}

void Trafficlight::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_ID;
	  
	 
}
Priority::Priority()
{
}

Priority::~Priority()
{
}

Priority::Priority(const Priority &x)
{
    m_ID = x.m_ID;
}

Priority::Priority(Priority &&x)
{
    m_ID = std::move(x.m_ID);
}

Priority& Priority::operator=(const Priority &x)
{
    m_ID = x.m_ID;
    
    return *this;
}

Priority& Priority::operator=(Priority &&x)
{
    m_ID = std::move(x.m_ID);
    
    return *this;
}

size_t Priority::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t Priority::getCdrSerializedSize(const Priority& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    return current_alignment - initial_alignment;
}

void Priority::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_ID;

}

void Priority::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_ID;
}

size_t Priority::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     

    return current_align;
}

bool Priority::isKeyDefined()
{
    return true;
}

void Priority::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_ID;
	  
}
Humidity::Humidity()
{

    m_sensor_val = 0.0;
}

Humidity::~Humidity()
{
}

Humidity::Humidity(const Humidity &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
}

Humidity::Humidity(Humidity &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = x.m_sensor_val;
}

Humidity& Humidity::operator=(const Humidity &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

Humidity& Humidity::operator=(Humidity &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

size_t Humidity::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t Humidity::getCdrSerializedSize(const Humidity& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void Humidity::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_sensor_id;

    scdr << m_sensor_val;

}

void Humidity::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_sensor_id;
    dcdr >> m_sensor_val;
}

size_t Humidity::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     


    return current_align;
}

bool Humidity::isKeyDefined()
{
    return true;
}

void Humidity::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_sensor_id;
	  
	 
}
Temperature::Temperature()
{

    m_sensor_val = 0.0;
}

Temperature::~Temperature()
{
}

Temperature::Temperature(const Temperature &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
}

Temperature::Temperature(Temperature &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = x.m_sensor_val;
}

Temperature& Temperature::operator=(const Temperature &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

Temperature& Temperature::operator=(Temperature &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

size_t Temperature::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t Temperature::getCdrSerializedSize(const Temperature& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void Temperature::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_sensor_id;

    scdr << m_sensor_val;

}

void Temperature::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_sensor_id;
    dcdr >> m_sensor_val;
}

size_t Temperature::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     


    return current_align;
}

bool Temperature::isKeyDefined()
{
    return true;
}

void Temperature::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_sensor_id;
	  
	 
}
Light::Light()
{

    m_sensor_val = false;
}

Light::~Light()
{
}

Light::Light(const Light &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
}

Light::Light(Light &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = x.m_sensor_val;
}

Light& Light::operator=(const Light &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

Light& Light::operator=(Light &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

size_t Light::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t Light::getCdrSerializedSize(const Light& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void Light::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_sensor_id;

    scdr << m_sensor_val;

}

void Light::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_sensor_id;
    dcdr >> m_sensor_val;
}

size_t Light::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     


    return current_align;
}

bool Light::isKeyDefined()
{
    return true;
}

void Light::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_sensor_id;
	  
	 
}
Speeding::Speeding()
{

    m_sensor_val = false;
}

Speeding::~Speeding()
{
}

Speeding::Speeding(const Speeding &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
}

Speeding::Speeding(Speeding &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = x.m_sensor_val;
}

Speeding& Speeding::operator=(const Speeding &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

Speeding& Speeding::operator=(Speeding &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

size_t Speeding::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t Speeding::getCdrSerializedSize(const Speeding& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void Speeding::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_sensor_id;

    scdr << m_sensor_val;

}

void Speeding::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_sensor_id;
    dcdr >> m_sensor_val;
}

size_t Speeding::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     


    return current_align;
}

bool Speeding::isKeyDefined()
{
    return true;
}

void Speeding::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_sensor_id;
	  
	 
}
GeoLocation::GeoLocation()
{


}

GeoLocation::~GeoLocation()
{
}

GeoLocation::GeoLocation(const GeoLocation &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
}

GeoLocation::GeoLocation(GeoLocation &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = std::move(x.m_sensor_val);
}

GeoLocation& GeoLocation::operator=(const GeoLocation &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

GeoLocation& GeoLocation::operator=(GeoLocation &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = std::move(x.m_sensor_val);
    
    return *this;
}

size_t GeoLocation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t GeoLocation::getCdrSerializedSize(const GeoLocation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void GeoLocation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_sensor_id;

    scdr << m_sensor_val;

}

void GeoLocation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_sensor_id;
    dcdr >> m_sensor_val;
}

size_t GeoLocation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     


    return current_align;
}

bool GeoLocation::isKeyDefined()
{
    return true;
}

void GeoLocation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_sensor_id;
	  
	 
}
Carpark::Carpark()
{


}

Carpark::~Carpark()
{
}

Carpark::Carpark(const Carpark &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
}

Carpark::Carpark(Carpark &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = std::move(x.m_sensor_val);
}

Carpark& Carpark::operator=(const Carpark &x)
{
    m_sensor_id = x.m_sensor_id;
    m_sensor_val = x.m_sensor_val;
    
    return *this;
}

Carpark& Carpark::operator=(Carpark &&x)
{
    m_sensor_id = std::move(x.m_sensor_id);
    m_sensor_val = std::move(x.m_sensor_val);
    
    return *this;
}

size_t Carpark::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t Carpark::getCdrSerializedSize(const Carpark& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void Carpark::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_sensor_id;

    scdr << m_sensor_val;

}

void Carpark::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_sensor_id;
    dcdr >> m_sensor_val;
}

size_t Carpark::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += ((10) * 1) + eprosima::fastcdr::Cdr::alignment(current_align, 1);
     


    return current_align;
}

bool Carpark::isKeyDefined()
{
    return true;
}

void Carpark::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_sensor_id;
	  
	 
}