// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file ddsDemoPublisher.cpp
 * This file contains the implementation of the publisher functions.
 *
 * This file was generated by the tool fastcdrgen.
 */
#define DATASIZE 10

#include <fastrtps/participant/Participant.h>
#include <fastrtps/attributes/ParticipantAttributes.h>
#include <fastrtps/publisher/Publisher.h>
#include <fastrtps/attributes/PublisherAttributes.h>

#include <fastrtps/Domain.h>

#include <fastrtps/utils/eClock.h>

#include "ddsDemoPublisher.h"

using namespace std;
#include "serial.h"
#include <thread>

//threads
void publishTrafficlight(serial::Serial *mySerial,Publisher *TL_writer, Publisher *PT_writer){
	//convert parsed std::string to std::array
    while(true){
		std::string parsed_data = mySerial->readline();
		if(!parsed_data.empty() && parsed_data.size()>=3){ //prevent segmentation fault
			// LamppostsCtrl lctrl;
			Trafficlight TL;
			// array<char,DATASIZE> data;
			std::string msg;
        	msg = "Data received from Trafficlight: " + parsed_data;
			msg += "\nASCI: ";
			int i;
			for(i = 0; i<parsed_data.size(); i++){
				msg += std::to_string((int)(parsed_data[i]))+ " ";
			}
			msg += "\n\n";

			int found = parsed_data.find("P!:");
			if(found!=std::string::npos){
				Priority PT;
				//memcpy(data.data(),(string("t")+parsed_data.substr(3,parsed_data.size()-5)).c_str(),DATASIZE); //t+index (eg t1,t2)
				// for(i=0; i<DATASIZE; i++){
				// 	std::cout << std::endl << (int)data[i] << std::endl;
				// }
				PT.ID(std::string("t")+parsed_data.substr(3,parsed_data.size()-5));
				PT_writer->write(&PT);
			}
			else{
				//traffic broadcast
				for(int i=0; i<parsed_data.size()-2; i++){
					Trafficlight TL;
					// memcpy(data.data(),(string("t")+std::to_string(i+1)).c_str(),DATASIZE); 
					TL.state(parsed_data[i]);
					TL.ID(std::string("t")+std::to_string(i+1));
					TL_writer->write(&TL);
				}
			}
			//std::cout << msg;

			// memcpy(data.data(),parsed_data.substr(0,parsed_data.size()-2).c_str(),DATASIZE); //copy the data without \r\n
			// // std::cout << std::endl << "Converted Data: SOF~" << data.data() << "~EOF";
			// lctrl.clusterID(data);
			// lctrl.value(0);
			// LPCTRL_writer->write(&lctrl);
			//std::cout << std::endl << std::endl;
		}
    }
}

void publishSensors(serial::Serial *mySerial, Publisher *T_writer, Publisher *H_writer, Publisher *L_writer,
					Publisher *S_writer, Publisher *GL_writer, Publisher *CP_writer){
	while(true){
		std::string parsed_data = mySerial->readline();
		if(!parsed_data.empty() && parsed_data.size()>=3){
			// Sensors SS;
			std::string msg;
			//Publish all the sensors
        	msg = "Data received from Sensors: " + parsed_data;
			msg += "\nASCI: ";
			int i;
			for(i = 0; i<parsed_data.size(); i++){
				msg += std::to_string((int)(parsed_data[i])) + " ";
			}

			//algorithm to split the sensor values
			int lastChar = -1;
			char type;
			std::string value;
			for(i = 0; i<parsed_data.size()-2; i++){
				if((int(parsed_data[i])>=97)){ //if its a lowercase character
					int startIndex = lastChar + 1;
					type = parsed_data[i];
					value = parsed_data.substr(startIndex,i-startIndex);
					lastChar = i;
					//std::cout << "Type: " << type << ", Value: " << value << std::endl;
					// array<char,DATASIZE> data;
					std::string id = "s1";
					if(type == 't'){ //write temperature
						Temperature T;
						float val = stof(value);
						// std::cout << "converted float T-val: " << val << std::endl;
						// memcpy(data.data(),id.c_str(),DATASIZE);
						T.sensor_id(id);
						T.sensor_val(val);
						// std::cout << "TEST DATA ==" << T.sensor_val() << std::endl;
						T_writer->write(&T);
					}
					if(type == 'h'){ //write temperature
						Humidity H;
						float val = stof(value);
						// memcpy(data.data(),id.c_str(),DATASIZE);
						H.sensor_id(id);
						H.sensor_val(val);
						H_writer->write(&H);
					}
					if(type == 'i'){ //write temperature
						Light L;
						char val = value[0];
						// memcpy(data.data(),id.c_str(),DATASIZE);
						L.sensor_id(id);
						L.sensor_val(val);
						L_writer->write(&L);
					}
					if(type == 's'){ //write temperature
						Speeding S;
						bool val;
						if(value.compare("1")==0)
							val = 1;
						else
							val = 0;
						S.sensor_id(id);
						S.sensor_val(val);
						S_writer->write(&S);
					}
					if(type == 'g'){ //write temperature
						GeoLocation GL;
						char val = value[0];
						GL.sensor_id(id);
						GL.sensor_val(val);
						GL_writer->write(&GL);
					}
					if(type == 'c'){ //write temperature
						Carpark CP;
						bool val;
						if(value.compare("1")==0)
							val = 1;
						else
							val = 0;
						//std::cout << "val: " << val << std::endl;
						CP.sensor_id(id);
						CP.sensor_val(val);
						CP_writer->write(&CP);
					}
				}
			}
			/*
			memcpy(data.data(),parsed_data.substr(0,parsed_data.size()-2).c_str(),30); //copy the data without \r\n
			// std::cout << std::endl << "Converted Data: SOF~" << data.data() << "~EOF";
			SS.readings(data);
			writer->write(&SS);
			*/
			msg += "\n\n";
			//std::cout << msg;
		}
    }
}

void publishLampposts(serial::Serial *mySerial,Publisher *LPBC_writer){
	while(true){
		std::string parsed_data = mySerial->readline();
		// Lampposts LP;
		// array<char,DATASIZE> data;
		std::string msg;

		if(!parsed_data.empty() && parsed_data.size()>=3){
        	msg = "Data received from Lampposts: " + parsed_data;
			msg += "\nASCI: ";
			int i;
			for(i = 0; i<parsed_data.size(); i++){
				msg += std::to_string((int)(parsed_data[i])) + " ";
			}
			for(int i=0; i<parsed_data.size()-2; i++){
				LamppostsBC LPBC;
				// memcpy(data.data(),(std::string("c")+std::to_string(i+1)).c_str(),DATASIZE); 
				if(parsed_data[i]=='0')
					LPBC.value(0);
				else
					LPBC.value(1);
				
				LPBC.clusterID(std::string("c")+std::to_string(i+1));
				LPBC_writer->write(&LPBC);
			}
			/*
			memcpy(data.data(),parsed_data.substr(0,parsed_data.size()-2).c_str(),DATASIZE); //copy the data without \r\n
			// std::cout << std::endl << "Converted Data: SOF~" << data.data() << "~EOF";
			LP.ID(data);
			writer->write(&LP);
			*/
			msg += "\n\n";
			//std::cout << msg;
		}
    }
}

ddsDemoPublisher::ddsDemoPublisher() : mp_participant(nullptr), CP_writer(nullptr), LPBC_writer(nullptr)
, TL_writer(nullptr), H_writer(nullptr), T_writer(nullptr), L_writer(nullptr), S_writer(nullptr), GL_writer(nullptr), PT_writer(nullptr) {}

ddsDemoPublisher::~ddsDemoPublisher() {	Domain::removeParticipant(mp_participant);}

bool ddsDemoPublisher::init()
{
	// Create RTPSParticipant
	
	ParticipantAttributes PParam;
	PParam.rtps.builtin.domainId = 0;
	PParam.rtps.builtin.leaseDuration = c_TimeInfinite;
	PParam.rtps.setName("Participant_publisher");  //You can put here the name you want
	mp_participant = Domain::createParticipant(PParam);
	if(mp_participant == nullptr)
		return false;
	
	//Register the type
	Domain::registerType(mp_participant,(TopicDataType*) &CP_type);
	Domain::registerType(mp_participant,(TopicDataType*) &LPBC_type);
	Domain::registerType(mp_participant,(TopicDataType*) &TL_type);
	Domain::registerType(mp_participant,(TopicDataType*) &H_type);
	Domain::registerType(mp_participant,(TopicDataType*) &T_type);
	Domain::registerType(mp_participant,(TopicDataType*) &L_type);
	Domain::registerType(mp_participant,(TopicDataType*) &S_type);
	Domain::registerType(mp_participant,(TopicDataType*) &GL_type);
	Domain::registerType(mp_participant,(TopicDataType*) &PT_type);
	// Create Publisher

	//Lampposts
	PublisherAttributes Wparam1;
	Wparam1.topic.topicKind = WITH_KEY;
	Wparam1.topic.topicDataType = CP_type.getName();  //This type MUST be registered
	Wparam1.topic.topicName = CP_type.getName();
	CP_writer = Domain::createPublisher(mp_participant,Wparam1,(PublisherListener*)&m_listener);
	if(CP_writer == nullptr)
		return false;
	std::cout << "Carpark writer initiated" << std::endl;

	PublisherAttributes Wparam3;
	Wparam3.topic.topicKind = WITH_KEY;
	Wparam3.topic.topicDataType = LPBC_type.getName();  //This type MUST be registered
	Wparam3.topic.topicName = LPBC_type.getName();
	LPBC_writer = Domain::createPublisher(mp_participant,Wparam3,(PublisherListener*)&m_listener);
	if(LPBC_writer == nullptr)
		return false;
	std::cout << "LamppostsBC writer initiated" << std::endl;

	PublisherAttributes Wparam4;
	Wparam4.topic.topicKind = WITH_KEY;
	Wparam4.topic.topicDataType = TL_type.getName();  //This type MUST be registered
	Wparam4.topic.topicName = TL_type.getName();
	TL_writer = Domain::createPublisher(mp_participant,Wparam4,(PublisherListener*)&m_listener);
	if(TL_writer == nullptr)
		return false;
	std::cout << "Trafficlight writer initiated" << std::endl;

	PublisherAttributes Wparam5;
	Wparam5.topic.topicKind = WITH_KEY;
	Wparam5.topic.topicDataType = H_type.getName();  //This type MUST be registered
	Wparam5.topic.topicName = H_type.getName();
	H_writer = Domain::createPublisher(mp_participant,Wparam5,(PublisherListener*)&m_listener);
	if(H_writer == nullptr)
		return false;
	std::cout << "Humidity writer initiated" << std::endl;

	PublisherAttributes Wparam6;
	Wparam6.topic.topicKind = WITH_KEY;
	Wparam6.topic.topicDataType = T_type.getName();  //This type MUST be registered
	Wparam6.topic.topicName = T_type.getName();
	T_writer = Domain::createPublisher(mp_participant,Wparam6,(PublisherListener*)&m_listener);
	if(T_writer == nullptr)
		return false;
	std::cout << "Temperature writer initiated" << std::endl;

	PublisherAttributes Wparam7;
	Wparam7.topic.topicKind = WITH_KEY;
	Wparam7.topic.topicDataType = L_type.getName();  //This type MUST be registered
	Wparam7.topic.topicName = L_type.getName();
	L_writer = Domain::createPublisher(mp_participant,Wparam7,(PublisherListener*)&m_listener);
	if(L_writer == nullptr)
		return false;
	std::cout << "Light writer initiated" << std::endl;

	PublisherAttributes Wparam8;
	Wparam8.topic.topicKind = WITH_KEY;
	Wparam8.topic.topicDataType = S_type.getName();  //This type MUST be registered
	Wparam8.topic.topicName = S_type.getName();
	S_writer = Domain::createPublisher(mp_participant,Wparam8,(PublisherListener*)&m_listener);
	if(S_writer == nullptr)
		return false;
	std::cout << "Speeding writer initiatedd" << std::endl;

	PublisherAttributes Wparam9;
	Wparam9.topic.topicKind = WITH_KEY;
	Wparam9.topic.topicDataType = GL_type.getName();  //This type MUST be registered
	Wparam9.topic.topicName = GL_type.getName();
	GL_writer = Domain::createPublisher(mp_participant,Wparam9,(PublisherListener*)&m_listener);
	if(GL_writer == nullptr)
		return false;
	std::cout << "GeoLocation writer initiated" << std::endl;

	PublisherAttributes Wparam10;
	Wparam10.topic.topicKind = WITH_KEY;
	Wparam10.topic.topicDataType = PT_type.getName();  //This type MUST be registered
	Wparam10.topic.topicName = PT_type.getName();
	PT_writer = Domain::createPublisher(mp_participant,Wparam10,(PublisherListener*)&m_listener);
	if(PT_writer == nullptr)
		return false;
	std::cout << "Priority writer initiated" << std::endl;
	
	return true;
}

void ddsDemoPublisher::PubListener::onPublicationMatched(Publisher* pub,MatchingInfo& info)
{
	if (info.status == MATCHED_MATCHING)
	{
		n_matched++;
		std::cout << "Publisher matched: " << pub->getAttributes().topic.getTopicName() << std::endl;
	}
	else
	{
		n_matched--;
		std::cout << "Publisher unmatched" << std::endl;
	}
}

void ddsDemoPublisher::run()
{
	std::string port1("/dev/lampposts");
    std::string port2("/dev/trafficlights");
    std::string port3("/dev/sensors");
    //define baud rate to use
    unsigned long baud = 115200;

    serial::Serial serialLP(port1, baud, serial::Timeout::simpleTimeout(1000));
    serial::Serial serialTL(port2, baud, serial::Timeout::simpleTimeout(1000));
    serial::Serial serialSS(port3, baud, serial::Timeout::simpleTimeout(1000));

	while(m_listener.n_matched == 0)
	{
		eClock::my_sleep(250); // Sleep 250 ms
	}
	
	thread threadTL(publishTrafficlight,&serialTL, TL_writer, PT_writer);
	thread threadSS(publishSensors,&serialSS, T_writer, H_writer, L_writer, S_writer
					, GL_writer, CP_writer);
	thread threadLP(publishLampposts,&serialLP, LPBC_writer);

	threadTL.join();
	threadSS.join();
	threadLP.join();
	

	// Publication code
	/*
	Lampposts LP;
	Priority PT;

	char ID[DATASIZE];
	char value;
	array<char,DATASIZE> IDarr; 
	*/
	
	/* Initialize your structure here */

	/*
	
	int msgsent = 0;
	char ch = 'y';
	do
	{
		if(ch == 'y')
		{
			std::cout << "Enter ID of light: ";
			cin >> ID;
			std::cout << "Enter value of light: ";
			cin >> value;

			memcpy(IDarr.data(),ID,DATASIZE); //convert from char[] to std::arrayd
			//set values
			LP.ID(IDarr);
			LP.value(value);
			std::cout<< "Sending LL cmd" <<std::endl;
			mp_publisher->write(&LP);  ++msgsent;

			//Write priority
			std::cout <<"Sending PT cmd" <<std::endl;
			array<char,DATASIZE> IDarr2; 
			char TESTDATA[DATASIZE] = "TEST";
			memcpy(IDarr2.data(),TESTDATA,DATASIZE);
			PT.ID(IDarr2);
			mp_publisher2->write(&PT);

			std::cout << "count=" << msgsent << ", send another command?(y-yes,n-stop): ";
		}
		else if(ch == 'n')
		{
			std::cout << "Stopping execution " << std::endl;
			break;
		}
		else
		{
			std::cout << "Command " << ch << " not recognized, please enter \"y/n\":";
		}
	}while(std::cin >> ch);
	*/
}